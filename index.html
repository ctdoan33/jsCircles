<html>
<head>
	<title>Javascript Box - OOP demo</title>
</head>
<body>
	<svg id="svg" xmlns="http://www.w3.org/2000/svg"></svg>
	<script>
		document.getElementById("svg").style = "width: 100%; height: 100%;" //svg element is size of browser
		function Circle(cx, cy, html_id,r,vx,vy){
			var html_id = html_id;
			this.info = { cx: cx,  cy: cy };
			//private function that generates a random number
			var randomNumberBetween = function(min, max){
				return Math.random()*(max-min) + min;
			}
			this.initialize = function(){
				//give a random velocity for the circle
				if(vx==undefined||vy==undefined){
					this.info.velocity = {
						x: randomNumberBetween(-3,3),
						y: randomNumberBetween(-3,3)
					}
				}else{
					this.info.velocity = {
						x: vx,
						y: vy
					}
				}
				//create a circle 
				var circle = makeSVG('circle',
					{ 	cx: this.info.cx,
						cy: this.info.cy,
						r:  r,
						id: html_id,
						style: "fill: "+random_color()
					})
				document.getElementById('svg').appendChild(circle);
			}
			this.update = function(time){
				var el = document.getElementById(html_id);
				//see if the circle is going outside the browser. if it is, reverse the velocity
				if( this.info.cx+Number(el.getAttribute("r")) > document.body.clientWidth || this.info.cx-Number(el.getAttribute("r")) < 0){
					this.info.velocity.x = this.info.velocity.x * -1;
				}
				if( this.info.cy+Number(el.getAttribute("r")) > document.body.clientHeight || this.info.cy-Number(el.getAttribute("r")) < 0){
					this.info.velocity.y = this.info.velocity.y * -1;
				}//corrects bounce based on radius of circle
				this.info.cx = this.info.cx + this.info.velocity.x*time;
				this.info.cy = this.info.cy + this.info.velocity.y*time;
				el.setAttribute("cx", this.info.cx);
				el.setAttribute("cy", this.info.cy);
			}
			//creates the SVG element and returns it
			var makeSVG = function(tag, attrs) {
				var el= document.createElementNS('http://www.w3.org/2000/svg', tag);
				for (var k in attrs){
					el.setAttribute(k, attrs[k]);
				}
				return el;
			}
			this.initialize(); 
		}
		function PlayGround(){ 
			var counter = 0;
			var circles = [ ];
			//a loop that updates the circle's position on the screen
			this.loop = function(){
				for(circle in circles){
					circles[circle].update(1);
				}
				//function to detect any collision
				function collision(){
					for(var i=0; i<circles.length; i++){
						for(var j=i+1; j<circles.length; j++){
							if(circles[i]==undefined||circles[j]==undefined){
							continue;
							}
							var circle1=document.getElementById(String(i)); //svg element has position, radius, id, and color as attributes
							var circle2=document.getElementById(String(j));
							var x1=circles[i].info.cx; //array object has position and velocity in info key
							var x2=circles[j].info.cx;
							var y1=circles[i].info.cy;
							var y2=circles[j].info.cy;
							var vx1=circles[i].info.velocity.x; //get velocities, used to determine final velocity for merges and bounces
							var vx2=circles[j].info.velocity.x;
							var vy1=circles[i].info.velocity.y;
							var vy2=circles[j].info.velocity.y;
							var distance=Math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)); //distance between centers of circles
							var r1=Number(circle1.getAttribute("r"));
							var r2=Number(circle2.getAttribute("r"));
							if(distance<r1+r2){ //distance when just touching is sum of radii
								// disappearOnCollision();
								function disappearOnCollision(){
								delete circles[i]; //delete from array, index is left undefined
								delete circles[j];
								document.getElementById("svg").removeChild(circle1); //remove svg element
								document.getElementById("svg").removeChild(circle2);
								}
								// mergeOnCollision();
								function mergeOnCollision(){
									var w1=r1*r1/(r1*r1+r2*r2); //calculate proportionate weights, based on total area
									var w2=r2*r2/(r1*r1+r2*r2);
									disappearOnCollision();
									playground.createNewCircle(x1*w1+x2*w2, y1*w1+y2*w2, Math.sqrt(r1*r1+r2*r2), vx1*w1+vx2*w2, vy1*w1+vy2*w2); 
								}//new circle has weighted position, radius, and velocity based on parent circles
								bounceOnCollision();
								function bounceOnCollision(){ //bounce calculations based on perfect elastic collision, conserved momentum, assuming equal masses
									var angle=Math.atan((x2-x1)/(y2-y1)); //angle of plane of collision, from right horizontal;
									var sinsq=Math.sin(angle)*Math.sin(angle); //common trig products to be used
									var sincos=Math.sin(angle)*Math.cos(angle);
									var cossq=Math.cos(angle)*Math.cos(angle);
									circles[i].info.velocity.x=vx1*cossq-vy1*sincos+vx2*sinsq+vy2*sincos;
									circles[i].info.velocity.y=-vx1*sincos+vy1*sinsq+vx2*sincos+vy2*cossq;
									circles[j].info.velocity.x=vx1*sinsq+vy1*sincos+vx2*cossq-vy2*sincos;
									circles[j].info.velocity.y=vx1*sincos+vy1*cossq-vx2*sincos+vy2*sinsq;
								}//each velocity is sum of components from (1)xvelocity of circle1 (2)yvelocity of circle1, (3)xvelocity of circle2, (4)yvelocity of circle2
								changeColorOnCollision();
								function changeColorOnCollision(){
									circle1.setAttribute("style", "fill: "+random_color());
									circle2.setAttribute("style", "fill: "+random_color());
								}
							}
						}
					}
				}
				collision();
			}
			this.createNewCircle = function(x,y,r,vx,vy){ //adjusted to accommodate radius and velocity inputs (functions calling and called by this also adjusted)
				var new_circle = new Circle(x,y,counter++,r,vx,vy);
				circles.push(new_circle);
				// console.log('created a new circle!', new_circle);
			}
			//create one circle when the game starts
			this.createNewCircle(document.body.clientWidth/2, document.body.clientHeight/2, 10);
		}
		var radius;
		var mousedoan_time;
		function getTime(){
			var date = new Date();
			return date.getTime();
		}
		document.onmousedown = function(e){
			mousedown_time = getTime();
		}
		document.onmouseup = function(e){
			radius = (getTime() - mousedown_time)/20;
		}
		var playground = new PlayGround();
		setInterval(playground.loop, 15);
		document.onclick = function(e) {
			playground.createNewCircle(e.x,e.y,radius);
		}
		function random_color(){//for random color
			var rgb=['a','b','c','d','e','f','0','1','2','3','4','5','6','7','8','9'];
			color='#';
			for(var i = 0; i < 6; i++){
				x=Math.floor((Math.random()*16));
				color+=rgb[x];
			}
			return color;
		}
</script>
</body>
</html>